---
title: "LBGFS2024: Exam Problem 1"
output: html_notebook
---

```{r setup, echo=FALSE}
set.seed(1216)
```

Simulation and test solution for Problem 1 of LBGFS2024-Exam. 


## Helper Function

```{r}
r_runif <- function(pn_n, pn_min, pn_max, pn_digits){
  return(round(runif(pn_n, 
                     min = pn_min,
                     max = pn_max),
               digits = pn_digits))
}
```


## Two Populations with Data of a Locus A
The two sets of parameters are defined below. 


### MAF
We start with the Minor Allele Frequency (MAF)

```{r}
vec_pop_names <- c("PopA", "PopB")
l_maf_summary <- list(Min = 0.3, Max = 0.4)
l_maf <- list()
for (p in vec_pop_names){
  l_maf[[p]] <- r_runif(1, pn_min = l_maf_summary$Min, pn_max = l_maf_summary$Max, pn_digits = 3)
}
l_maf
```


### Genotypic Values

```{r}
l_geno_val_summary <- list(hom_val_a = list(Min = 1, Max = 99),
                               het_val_d = list(Min = 1, Max = 39))
l_geno_val <- list()
for (p in vec_pop_names){
  l_cur_geno_val <- list(hom_val_a = r_runif(1, 
                                            pn_min = l_geno_val_summary$hom_val_a$Min, 
                                            pn_max = l_geno_val_summary$hom_val_a$Max,
                                            pn_digits = 1),
                        het_val_d = r_runif(1, 
                                            pn_min = l_geno_val_summary$het_val_d$Min, 
                                            pn_max = l_geno_val_summary$het_val_d$Max,
                                            pn_digits = 1))
  l_geno_val[[p]] <- l_cur_geno_val
}
# set d-value of population A to zero
l_geno_val$PopA$het_val_d <- 0
l_geno_val
```


### Genotypes
The genotypes are generated 

```{r}
n_nr_obs <- 30
n_nr_loci_per_pop <- 1
vec_geno_code <- c(0:2)
l_geno_code <- list()
for (p in vec_pop_names){
  cur_mat_geno_code <- matrix(nrow = n_nr_obs, ncol = n_nr_loci_per_pop)
  for (n_loci_idx in 1:n_nr_loci_per_pop){
    # sample genotypes according to HW-equilibrium
    cur_mat_geno_code[,n_loci_idx] <- sample(vec_geno_code,
                                             size = n_nr_obs,
                                             replace = T,
                                             prob = c((1 - l_maf[[p]])^2,
                                                      2 * l_maf[[p]] * (1-l_maf[[p]]),
                                                      l_maf[[p]]^2))
  }
  
  l_geno_code[[p]] <- cur_mat_geno_code
}
l_geno_code
```


### Generate Observations
Observations are generated by taking everything together

```{r}
n_res_sd <- 13.15
l_obs <- list()
# p <- vec_pop_names[1]
for (p in vec_pop_names){
  cur_mat_m1z1 <- l_geno_code[[p]] - 1
  cur_het_mat <- matrix(0, nrow = nrow(cur_mat_m1z1), ncol = ncol(cur_mat_m1z1))
  cur_het_mat[cur_mat_m1z1 == 0] <- 1
  vec_cur_obs <- cur_mat_m1z1 * l_geno_val[[p]]$hom_val_a + cur_het_mat * l_geno_val[[p]]$het_val_d + rnorm(n_nr_obs, sd = n_res_sd)
  l_obs[[p]] <- vec_cur_obs
}
l_obs
```


### Create Dataset
Put together the dataset for both populations, start with A

```{r}
tbl_pop_A <- tibble::tibble(Animal = 1:n_nr_obs,
                            Genotype = l_geno_code$PopA[,1],
                            Response = round(l_obs$PopA[,1], digits = 2))
tbl_pop_A
```

The same for B


```{r}
tbl_pop_B <- tibble::tibble(Animal = 1:n_nr_obs,
                            Genotype = l_geno_code$PopB[,1],
                            Response = round(l_obs$PopB[,1], digits = 2))
tbl_pop_B
```


## Solution

### Allele frequencies
Allele frequencies are computed from vector of genotype codes

```{r}
get_maf <- function(pvec_genotype_code){
  # check whether, codes are on 0-1-2 coding
  vec_genotype_code <- pvec_genotype_code
  if (min(vec_genotype_code) < 0){
    vec_genotype_code <- vec_genotype_code + 1
  }
  # get maf via mean/2
  return(mean(vec_genotype_code)/2)
}
```



* Population A

```{r}
maf_A <- get_maf(pvec_genotype_code = tbl_pop_A$Genotype)
maf_A
```

* Population B

```{r}
maf_B <- get_maf(pvec_genotype_code = tbl_pop_B$Genotype)
maf_B
```


### Genotype Values
Genotypic values are computed based on group means

```{r}
get_genotype_values <- function(ptbl_one_locus, 
                                ps_colname_genotype = "Genotype",
                                ps_colname_response = "Response"){
  # homozygous genotype value a
  tbl_hom_pos <- ptbl_one_locus[ptbl_one_locus[[ps_colname_genotype]] == 2,]
  n_group_mean_hom_pos <- mean(tbl_hom_pos[[ps_colname_response]])
  tbl_hom_neg <- ptbl_one_locus[ptbl_one_locus[[ps_colname_genotype]] == 0,]
  n_group_mean_hom_neg <- mean(tbl_hom_neg[[ps_colname_response]])
  n_value_a <- (n_group_mean_hom_pos - n_group_mean_hom_neg) / 2
  # heterozygous genotype value d
  tbl_het <- ptbl_one_locus[ptbl_one_locus[[ps_colname_genotype]] == 1,]
  n_group_mean_het <- mean(tbl_het[[ps_colname_response]])
  n_value_d <- n_group_mean_het - n_group_mean_hom_neg - n_value_a
  # return result
  return(list(a = n_value_a,
              d = n_value_d))
}
```

* Population A: 

```{r}
n_genotype_value_popA <- get_genotype_values(ptbl_one_locus = tbl_pop_A)
n_genotype_value_popA
```

* Population B: 

```{r}
n_genotype_value_popB <- get_genotype_values(ptbl_one_locus = tbl_pop_B)
n_genotype_value_popB
```


### Breeding Values

```{r}
get_breeding_values <- function(ptbl_one_locus){
  # get maf
  n_maf <- get_maf(pvec_genotype_code = ptbl_one_locus$Genotype)
  # get genotypic values
  l_geno_val <- get_genotype_values(ptbl_one_locus = ptbl_one_locus)
  # compute alpha
  n_alpha <- l_geno_val$a + (1-2*n_maf) * l_geno_val$d
  # compute breeding values for three genotypes
  vec_bv_geno <- c(-2 * n_maf * n_alpha,
                   (1 - 2 * n_maf) * n_alpha,
                   2 * (1-n_maf) * n_alpha)
  # set breeding values
  tbl_bv_all_ani <- tibble::tibble(Animal = ptbl_one_locus$Animal,
                                   BV = rep(NA, nrow(ptbl_one_locus)))
  for (idx in 1:nrow(tbl_bv_all_ani)){
    tbl_bv_all_ani$BV[idx] <- vec_bv_geno[ptbl_one_locus$Genotype[idx] + 1]
  }
  return(tbl_bv_all_ani)
}
```

* Population A:

```{r}
tbl_bv_popA <- get_breeding_values(ptbl_one_locus = tbl_pop_A)
tbl_bv_popA
```


* Population B:

```{r}
tbl_bv_popB <- get_breeding_values(ptbl_one_locus = tbl_pop_B)
tbl_bv_popB
```

### Dominance Deviation

```{r}
# compute dominance deviations
get_dom_dev <- function(ptbl_one_locus){
  # get maf
  n_maf <- get_maf(pvec_genotype_code = ptbl_one_locus$Genotype)
  # get genotypic values
  l_geno_val <- get_genotype_values(ptbl_one_locus = ptbl_one_locus)
  # dominance deviation
  vec_dom_dev <- c(-2 * n_maf^2 * l_geno_val$d,
                   2 * n_maf * (1-n_maf) * l_geno_val$d,
                   -2 * (1-n_maf)^2 * l_geno_val$d)
  
  # set dominance_deviations
  tbl_dd_all_ani <- tibble::tibble(Animal = ptbl_one_locus$Animal,
                                   DD = rep(NA, nrow(ptbl_one_locus)))
  for (idx in 1:nrow(tbl_dd_all_ani)){
    tbl_dd_all_ani$DD[idx] <- vec_dom_dev[ptbl_one_locus$Genotype[idx] + 1]
  }
  return(tbl_dd_all_ani)
}
```


### Plots

The response is plotted 

* Pop A

```{r, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)

group_mean_A <- tbl_pop_A %>%
  group_by(Genotype) %>%
  summarise(mean_response = mean(Response, na.rm = T))

p_popA <- ggplot(data = tbl_pop_A, aes(x = Genotype, y = Response)) + 
  geom_point() +  # Original points
  geom_point(data = group_mean_A, aes(x = Genotype, y = mean_response), 
             color = "red", shape = 4, size = 4) +  # Add group means as red crosses
  scale_x_continuous(breaks = function(x) unique(floor(pretty(x)))) +  # Show only integer ticks on x-axis
  scale_y_continuous(breaks = NULL) +  # Remove ticks and labels on y-axis
  labs(title = "Response by Genotype with Group Means",
       y = "Response", x = "Genotype")
p_popA
```

The solution plot

```{r}
p_popA_sol <- ggplot(data = tbl_pop_A, aes(x = Genotype, y = Response)) + 
  geom_point() +  # Original points
  geom_point(data = group_mean_A, aes(x = Genotype, y = mean_response), 
             color = "red", shape = 4, size = 4) +  # Add group means as red crosses
  scale_x_continuous(breaks = function(x) unique(floor(pretty(x)))) +  # Show only integer ticks on x-axis
  labs(title = "Response by Genotype with Group Means",
       y = "Response", x = "Genotype")
p_popA_sol
```



* Population B

```{r, message=FALSE, warning=FALSE}
group_mean_B <- tbl_pop_B %>%
  group_by(Genotype) %>%
  summarise(mean_response = mean(Response, na.rm = T))

p_popB <- ggplot(data = tbl_pop_B, aes(x = Genotype, y = Response)) + 
  geom_point() +  # Original points
  geom_point(data = group_mean_B, aes(x = Genotype, y = mean_response), 
             color = "red", shape = 4, size = 4) +  # Add group means as red crosses
  scale_x_continuous(breaks = function(x) unique(floor(pretty(x)))) +  # Show only integer ticks on x-axis
  scale_y_continuous(breaks = NULL) +  # Remove ticks and labels on y-axis⁄
  labs(title = "Response by Genotype with Group Means",
       y = "Response", x = "Genotype")
p_popB
```

Solution plot

```{r}
p_popB_sol <- ggplot(data = tbl_pop_B, aes(x = Genotype, y = Response)) + 
  geom_point() +  # Original points
  geom_point(data = group_mean_B, aes(x = Genotype, y = mean_response), 
             color = "red", shape = 4, size = 4) +  # Add group means as red crosses
  scale_x_continuous(breaks = function(x) unique(floor(pretty(x)))) +  # Show only integer ticks on x-axis
  labs(title = "Response by Genotype with Group Means",
       y = "Response", x = "Genotype")
p_popB_sol
```


## Write Data to File

```{r}
s_delim_char <- ","
s_data_path_popA <- here::here("docs", "data", "exam_p1_popA.csv")
readr::write_delim(tbl_pop_A, file = s_data_path_popA, delim = s_delim_char)
s_data_path_popB <- here::here("docs", "data", "exam_p1_popB.csv")
readr::write_delim(tbl_pop_B, file = s_data_path_popB, delim = s_delim_char)
```


